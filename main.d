import autogen.caps;
import std.stdio;
import std.conv;
import std.array;
import std.string;
import core.vararg;

/*
   Info about the terminfo compiled format are hard to find,
   as almost everyone uses ncurses / tic / infocmp / tput

   Most relevant stuff was found on:

    - terminfo(5)   [! the capacity list is sorted by alphabetical order,
                       not in order of appearance in a terminfo file ]
                    [ it probably is generated by ncurses/man/MKterminfo.sh, which sorts it ]
    - Terminfo Source Format (ENHANCED CURSE) on the Single UNIX Specification - opengroup.org
    - unibilium's header description (unibilium/secret/terminfo.pod)


    - tic's source (ncurses/include/tic.h) [ only available resource with the
                                             ordered capacity table? ]

    A lot of ncurses' terminfo handling code seem to be generated using ncurses/include/Caps file
    There are a bunch of awk / makefile / sh scripts using it in ncurses/ncurses/tinfo/ and in ncurses/man

    TODO a bit more doc
*/

// TODO terminfo extended capacities

struct Terminfo {
    struct Header {
        ushort magic;
        ushort name_size;
        ushort bool_count;
        ushort num_count;
        ushort string_count;
        ushort table_size;
    };

    Header header;
    string name;
    string description;
    bool[] bools;
    ushort[] nums;
    char[][] strings;
}

Terminfo parse_terminfo(string path) {
    File f = File(path, "r");
    Terminfo ti;
    f.rawRead((&ti.header)[0..1]);
    assert(ti.header.magic == octal!432);

    // name <=> term_name | [ ... | ] description
    char[] _name_section = new char[ti.header.name_size];
    f.rawRead(_name_section);
    string name_section = cast(string)_name_section;
    string[] splitted_name = name_section.split("|");
    assert(splitted_name.length >= 2);
    ti.name = splitted_name[0];
    ti.description = splitted_name[$-1][0..$-1];  // remove trailing \0

    ti.bools = new bool[ti.header.bool_count];
    f.rawRead(ti.bools);

    if((ti.header.name_size + ti.header.bool_count) % 2 != 0)
        f.seek(1, SEEK_CUR);  // padding

    ti.nums = new ushort[ti.header.num_count];
    f.rawRead(ti.nums);

    // string table

    ushort[] string_offsets = new ushort[ti.header.string_count];
    f.rawRead(string_offsets);
    char[] string_table = new char[ti.header.table_size];
    f.rawRead(string_table);
    ti.strings = new char[][ti.header.string_count];
    foreach(i, off; string_offsets)
        if(off != 0xffff) {
            assert(off < 0x7fff);
            long string_end = indexOf(string_table, '\0', off);
            if(off == string_end) {
                ti.strings[i] = new char[0];
            } else {
                assert(string_end > off,
                       format("index error %d, at %d, offset %u",
                              string_end, i, off));
                ti.strings[i] = string_table[off..string_end];
            }
        }

    return ti;
}

void print_term_caps(const ref Terminfo ti) {
    writeln("bools:");
    foreach(i, b; ti.bools)
        if(b)
            writefln("\t%s", cast(bool_caps)i);

    writeln();
    writeln("nums:");
    foreach(i, n; ti.nums)
        if(n != 0xffff)
            writefln("\t%s = %d", cast(num_caps)i, n);

    /* writeln(); */
    /* writeln("strings:"); */
    /* foreach(i, s; ti.strings) */
    /*     if(s.length != 0) */
    /*         writefln("\t%s = %s", cast(str_caps)i, ti.strings[i]); */
}


// TODO string cap interpretation only supports int args atm
// (xterm & rxvt only seem to need ints)
// but the spec allows string as arguments
// TODO 'u6' cap does a %d with nothing on the stack...

string _interpret_cap(string s, ref uint i, ref int[] stack, ref int[] args, bool eval) {
    // i <=> string index
    string o = "";
    while(i < s.length) {
        char c = s[i++];
        if(c != '%') {
            if(eval)
                o ~= c;
        } else {
            c = s[i++];
            switch(c) {
                case '%':
                    if(!eval) break;
                    o ~= '%';
                    break;

                case 'd':
                    if(!eval) break;
                    assert(stack.length > 0);
                    o ~= to!string(stack.back);
                    stack.popBack();
                    break;

                case 'p':
                    if(!eval) break;
                    char n = s[i++];
                    assert(n >= '1' && n <= '9');
                    int arg_idx = (n - '1');
                    assert(arg_idx < args.length);
                    stack ~= args[arg_idx];
                    break;

                case 'i':
                    if(!eval) break;
                    if(args.length > 0) args[0]++;
                    if(args.length > 1) args[1]++;
                    break;

                case '{':
                    int n = 0;
                    while(true) {
                        char d = s[i++];
                        if(d == '}')
                            break;
                        else if(d >= '0' && d <= '9')
                            n = 10*n + (d - '0');
                        else
                            assert(0);
                    }
                    if(!eval) break;
                    stack ~= n;
                    break;

                case '?':
                    o ~= _interpret_cap(s, i, stack, args, eval);  // read & interpret everything inside the condition
                    assert(s[i] == 't');
                    i++;
                    bool current_eval = eval;
                    while(true) {
                        bool eval_then = false;
                        bool eval_else = false;
                        if(current_eval) {
                            assert(stack.length > 0);
                            if(stack.back != 0)
                                eval_then = true;
                            else
                                eval_else = true;
                            stack.popBack();
                        }
                        o ~= _interpret_cap(s, i, stack, args, eval_then);
                        char next = s[i++];
                        if(next == ';')
                            break;
                        assert(next == 'e');
                        o ~= _interpret_cap(s, i, stack, args, eval_else);
                        next = s[i++];
                        if(next == ';')
                            break;
                        assert(next == 't', "expected ; or t after e, got " ~ to!string(next));  // "else-if a la Algol 68"
                        current_eval = eval_else;
                    }
                    break;

                // TODO autogen logical operations
                case '>':
                    if(!eval) break;
                    assert(stack.length >= 2);
                    int a = stack.back;
                    stack.popBack();
                    int b = stack.back;
                    stack.popBack();
                    stack ~= (b > a) ? 1 : 0;  // TODO seemed more logical to swap the args but its against the spec, which may no be correct
                    break;

                case '=':
                    if(!eval) break;
                    assert(stack.length >= 2, "trying to eval = but cannot pop twice. stack is: " ~ to!string(stack) ~ ", before: " ~ s[0..i] ~ " ; after: " ~ s[i+1..$]);
                    int a = stack.back;
                    stack.popBack();
                    int b = stack.back;
                    stack.popBack();
                    stack ~= (b == a) ? 1 : 0;  // TODO seemed more logical to swap the args but its against the spec, which may no be correct
                    break;

                case ';':
                case 'e':
                case 't':
                    i--;
                    return o;

                // TODO handle everything else
                default: assert(0, "unknown cap param type %" ~ to!string(c));
            }
        }
    }
    return o;
}

string interpret_string_cap(ref Terminfo ti, str_caps cap, int[] args...) {
    // TODO asserts should also crash in release mode
    assert(cap < ti.header.string_count && ti.strings[cap].length > 0);
    string s = ti.strings[cap].idup;
    assert(s.indexOf('<') == -1);  // TODO
    assert(s.indexOf('^') == -1);  // TODO
    assert(s.indexOf("%s") == -1);  // TODO

    int[] stack;
    uint str_idx = 0;
    string o = _interpret_cap(s, str_idx, stack, args, true);
    assert(str_idx == s.length);
    return o;
}

void main(string[] args) {
    Terminfo ti = parse_terminfo("/usr/share/terminfo/r/rxvt-unicode-256color");
    /* print_term_caps(ti); */

    /* str_caps cap = str_caps.clear_screen; */
    str_caps cap = str_caps.parm_rindex;
    /* writeln(interpret_string_cap(ti, cap, 2).replace("\033", "\\033")); */
    /* write(interpret_string_cap(ti, cap, 3)); */


    write(interpret_string_cap(ti, str_caps.cursor_address, 7, 22));
    write(interpret_string_cap(ti, str_caps.enter_bold_mode));
    write(interpret_string_cap(ti, str_caps.enter_italics_mode));

    static if(1) {
        assert(args.length > 2);
        write(interpret_string_cap(ti, str_caps.set_background, to!int(args[1])));
        write(interpret_string_cap(ti, str_caps.set_foreground, to!int(args[2])));
        writeln("plouf");
    } else if(0) {
        for(uint i=0 ; i<20 ; i++) {
            write(interpret_string_cap(ti, str_caps.set_background, i));
            writeln("plouf");
        }
    }

    /* writeln(interpret_string_cap(ti, str_caps.set_background, to!int(args[1])).replace("\033", "\\033")); */
}
