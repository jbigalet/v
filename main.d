import std.stdio;
import std.conv;
import std.array;
import std.string;
import core.vararg;
import core.thread;
import std.algorithm;
import std.random;
import core.sys.posix.signal;
import core.stdc.stdlib;
import cstdio = core.stdc.stdio;
import core.sys.posix.sys.ioctl;
import std.functional;
import core.sys.posix.unistd;
import core.sys.linux.termios;
import std.typecons;
import std.process;
import std.mmfile;

import autogen.caps;
import keysym;

enum SIGWINCH = 28;

/*
   Info about the terminfo compiled format are hard to find,
   as almost everyone uses ncurses / tic / infocmp / tput

   Most relevant stuff was found on:

    - terminfo(5)   [! the capacity list is sorted by alphabetical order,
                       not in order of appearance in a terminfo file ]
                    [ it probably is generated by ncurses/man/MKterminfo.sh, which sorts it ]
    - Terminfo Source Format (ENHANCED CURSE) on the Single UNIX Specification - opengroup.org
    - unibilium's header description (unibilium/secret/terminfo.pod)


    - tic's source (ncurses/include/tic.h) [ only available resource with the
                                             ordered capacity table? ]

    A lot of ncurses' terminfo handling code seem to be generated using ncurses/include/Caps file
    There are a bunch of awk / makefile / sh scripts using it in ncurses/ncurses/tinfo/ and in ncurses/man

    TODO a bit more doc
*/

// TODO terminfo extended capacities

struct Terminfo {
    struct Header {
        ushort magic;
        ushort name_size;
        ushort bool_count;
        ushort num_count;
        ushort string_count;
        ushort table_size;
    };

    Header header;
    string name;
    string description;
    bool[] bools;
    ushort[] nums;
    char[][] strings;
}

Terminfo parse_terminfo(string path) {
    File f = File(path, "r");
    Terminfo ti;
    f.rawRead((&ti.header)[0..1]);
    assert(ti.header.magic == octal!432);

    // name <=> term_name | [ ... | ] description
    char[] _name_section = new char[ti.header.name_size];
    f.rawRead(_name_section);
    string name_section = cast(string)_name_section;
    string[] splitted_name = name_section.split("|");
    assert(splitted_name.length >= 2);
    ti.name = splitted_name[0];
    ti.description = splitted_name[$-1][0..$-1];  // remove trailing \0

    ti.bools = new bool[ti.header.bool_count];
    f.rawRead(ti.bools);

    if((ti.header.name_size + ti.header.bool_count) % 2 != 0)
        f.seek(1, SEEK_CUR);  // padding

    ti.nums = new ushort[ti.header.num_count];
    f.rawRead(ti.nums);

    // string table

    ushort[] string_offsets = new ushort[ti.header.string_count];
    f.rawRead(string_offsets);
    char[] string_table = new char[ti.header.table_size];
    f.rawRead(string_table);
    ti.strings = new char[][ti.header.string_count];
    foreach(i, off; string_offsets)
        if(off != 0xffff) {
            assert(off < 0x7fff);
            long string_end = indexOf(string_table, '\0', off);
            if(off == string_end) {
                ti.strings[i] = new char[0];
            } else {
                assert(string_end > off,
                       format("index error %d, at %d, offset %u",
                              string_end, i, off));
                ti.strings[i] = string_table[off..string_end];
            }
        }

    return ti;
}

void print_term_caps(const ref Terminfo ti) {
    writeln("bools:");
    foreach(i, b; ti.bools)
        if(b)
            writefln("\t%s", cast(bool_caps)i);

    writeln();
    writeln("nums:");
    foreach(i, n; ti.nums)
        if(n != 0xffff)
            writefln("\t%s = %d", cast(num_caps)i, n);

    /* writeln(); */
    /* writeln("strings:"); */
    /* foreach(i, s; ti.strings) */
    /*     if(s.length != 0) */
    /*         writefln("\t%s = %s", cast(str_caps)i, ti.strings[i]); */
}


// TODO very slow to do this every time (setb/g strings are pretty huge for instance)
// TODO string cap interpretation only supports int args atm
// (xterm & rxvt only seem to need ints)
// but the spec allows string as arguments
// TODO 'u6' cap does a %d with nothing on the stack...

string _interpret_cap(string s, ref uint i, ref int[] stack, ref int[] args, bool eval) {
    // i <=> string index
    string o = "";
    while(i < s.length) {
        char c = s[i++];
        if(c != '%') {
            if(eval)
                o ~= c;
        } else {
            c = s[i++];
            switch(c) {
                case '%':
                    if(!eval) break;
                    o ~= '%';
                    break;

                case 'd':
                    if(!eval) break;
                    assert(stack.length > 0);
                    o ~= to!string(stack.back);
                    stack.popBack();
                    break;

                case 'p':
                    if(!eval) break;
                    char n = s[i++];
                    assert(n >= '1' && n <= '9');
                    int arg_idx = (n - '1');
                    assert(arg_idx < args.length);
                    stack ~= args[arg_idx];
                    break;

                case 'i':
                    if(!eval) break;
                    if(args.length > 0) args[0]++;
                    if(args.length > 1) args[1]++;
                    break;

                case '{':
                    int n = 0;
                    while(true) {
                        char d = s[i++];
                        if(d == '}')
                            break;
                        else if(d >= '0' && d <= '9')
                            n = 10*n + (d - '0');
                        else
                            assert(0);
                    }
                    if(!eval) break;
                    stack ~= n;
                    break;

                case '?':
                    o ~= _interpret_cap(s, i, stack, args, eval);  // read & interpret everything inside the condition
                    assert(s[i] == 't');
                    i++;
                    bool current_eval = eval;
                    while(true) {
                        bool eval_then = false;
                        bool eval_else = false;
                        if(current_eval) {
                            assert(stack.length > 0);
                            if(stack.back != 0)
                                eval_then = true;
                            else
                                eval_else = true;
                            stack.popBack();
                        }
                        o ~= _interpret_cap(s, i, stack, args, eval_then);
                        char next = s[i++];
                        if(next == ';')
                            break;
                        assert(next == 'e');
                        o ~= _interpret_cap(s, i, stack, args, eval_else);
                        next = s[i++];
                        if(next == ';')
                            break;
                        assert(next == 't', "expected ; or t after e, got " ~ to!string(next));  // "else-if a la Algol 68"
                        current_eval = eval_else;
                    }
                    break;

                // TODO autogen logical operations
                case '>':
                    if(!eval) break;
                    assert(stack.length >= 2);
                    int a = stack.back;
                    stack.popBack();
                    int b = stack.back;
                    stack.popBack();
                    stack ~= (b > a) ? 1 : 0;  // TODO seemed more logical to swap the args but its against the spec, which may no be correct
                    break;

                case '=':
                    if(!eval) break;
                    assert(stack.length >= 2, "trying to eval = but cannot pop twice. stack is: " ~ to!string(stack) ~ ", before: " ~ s[0..i] ~ " ; after: " ~ s[i+1..$]);
                    int a = stack.back;
                    stack.popBack();
                    int b = stack.back;
                    stack.popBack();
                    stack ~= (b == a) ? 1 : 0;  // TODO seemed more logical to swap the args but its against the spec, which may no be correct
                    break;

                case ';':
                case 'e':
                case 't':
                    i--;
                    return o;

                // TODO handle everything else
                default: assert(0, "unknown cap param type %" ~ to!string(c));
            }
        }
    }
    return o;
}

string interpret_string_cap(ref Terminfo ti, str_caps cap, int[] args...) {
    // TODO asserts should also crash in release mode
    assert(cap < ti.header.string_count && ti.strings[cap].length > 0);
    string s = ti.strings[cap].idup;
    assert(s.indexOf('<') == -1);  // TODO
    assert(s.indexOf('^') == -1);  // TODO
    assert(s.indexOf("%s") == -1);  // TODO

    int[] stack;
    uint str_idx = 0;
    string o = _interpret_cap(s, str_idx, stack, args, true);
    assert(str_idx == s.length);
    return o;
}


struct Terminal {
    Terminfo info;
    int width;
    int height;
    Nullable!termios old_termios;
    bool ca_mode = false;

    void update_size() {
        winsize size;
        ioctl(0, TIOCGWINSZ, &size);
        width  = size.ws_col;
        height = size.ws_row;
    }

    /* void interpret_cap(str_caps cap)(int[] args...) { */
    /*     write(interpret_string_cap(this.info, cap, args)); */
    /* } */

    @property auto opDispatch(string name, T...)(T args) {
        static if(name == "enter_ca_mode")
            ca_mode = true;
        else static if(name == "exit_ca_mode")
            ca_mode = false;

        return write(mixin("interpret_string_cap(this.info, str_caps." ~ name ~ ", args)"));
        /* return toDelegate(mixin("&interpret_cap!(str_caps." ~ name ~ ")")); */
    }
}


Terminal term;  // for the signal handlers
Split main_split;

extern(C)
void size_update_handler(int d=0) {
    term.update_size();
    main_split.redraw();
}

void cleanup_term() {
    if(term.ca_mode)
        term.exit_ca_mode();

    if(!term.old_termios.isNull()) {
        tcsetattr(STDIN_FILENO, TCSANOW, &term.old_termios.get());
        term.old_termios.nullify();
    }

    writeln("cleaning up...");
}

extern(C) void sigint_handler(int d) {
    cleanup_term();
    writeln("caught sigint");
    /* exit(1); */  // TODO
    assert(0);
}

extern(C) void sigsegv_handler(int d) {
    cleanup_term();
    writeln("caught sigsegv");
    /* exit(1); */
    assert(0);
}


// Xlib bindings

struct Display;
alias ulong Window;

// TODO make mixin generating bitflags
enum EventMask : long {
    NoEventMask              = 0,
    KeyPressMask             = 1 << 0,
    KeyReleaseMask           = 1 << 1,
    ButtonPressMask          = 1 << 2,
    ButtonReleaseMask        = 1 << 3,
    EnterWindowMask          = 1 << 4,
    LeaveWindowMask          = 1 << 5,
    PointerMotionMask        = 1 << 6,
    PointerMotionHintMask    = 1 << 7,
    Button1MotionMask        = 1 << 8,
    Button2MotionMask        = 1 << 9,
    Button3MotionMask        = 1 << 10,
    Button4MotionMask        = 1 << 11,
    Button5MotionMask        = 1 << 12,
    ButtonMotionMask         = 1 << 13,
    KeymapStateMask          = 1 << 14,
    ExposureMask             = 1 << 15,
    VisibilityChangeMask     = 1 << 16,
    StructureNotifyMask      = 1 << 17,
    ResizeRedirectMask       = 1 << 18,
    SubstructureNotifyMask   = 1 << 19,
    SubstructureRedirectMask = 1 << 20,
    FocusChangeMask          = 1 << 21,
    PropertyChangeMask       = 1 << 22,
    ColormapChangeMask       = 1 << 23,
    OwnerGrabButtonMask      = 1 << 24,
}

enum EventType : int {
    KeyPress = 2,
    KeyRelease,
    ButtonPress,
    ButtonRelease,
    MotionNotify,
    EnterNotify,
    LeaveNotify,
    FocusIn,
    FocusOut,
    KeymapNotify,
    Expose,
    GraphicsExpose,
    NoExpose,
    VisibilityNotify,
    CreateNotify,
    DestroyNotify,
    UnmapNotify,
    MapNotify,
    MapRequest,
    ReparentNotify,
    ConfigureNotify,
    ConfigureRequest,
    GravityNotify,
    ResizeRequest,
    CirculateNotify,
    CirculateRequest,
    PropertyNotify,
    SelectionClear,
    SelectionRequest,
    SelectionNotify,
    ColormapNotify,
    ClientMessage,
    MappingNotify,
    GenericEvent,
    LASTEvent,
}



// TODO bind yet to be binded sub events

// X's bool type is an int -_-
enum Bool : int {
    False,
    True
}

struct XKeyEvent {
    int type;                /* of event */
    ulong serial;            /* # of last request processed by server */
    Bool send_event;         /* true if this came from a SendEvent request */
    Display* display;        /* Display the event was read from */
    Window window;           /* "event" window it is reported relative to */
    Window root;             /* root window that the event occurred on */
    Window subwindow;        /* child window */
    ulong time;              /* milliseconds */
    int x, y;                /* pointer x, y coordinates in event window */
    int x_root, y_root;      /* coordinates relative to root */
    uint state;              /* key or button mask */
    uint keycode;            /* detail */
    Bool same_screen;        /* same screen flag */
}

alias XKeyPressedEvent  = XKeyEvent;
alias XKeyReleasedEvent = XKeyEvent;

union XEvent {
    int type;
    /* XAnyEvent xany; */
    XKeyEvent xkey;
    /* XButtonEvent xbutton; */
    /* XMotionEvent xmotion; */
    /* XCrossingEvent xcrossing; */
    /* XFocusChangeEvent xfocus; */
    /* XExposeEvent xexpose; */
    /* XGraphicsExposeEvent xgraphicsexpose; */
    /* XNoExposeEvent xnoexpose; */
    /* XVisibilityEvent xvisibility; */
    /* XCreateWindowEvent xcreatewindow; */
    /* XDestroyWindowEvent xdestroywindow; */
    /* XUnmapEvent xunmap; */
    /* XMapEvent xmap; */
    /* XMapRequestEvent xmaprequest; */
    /* XReparentEvent xreparent; */
    /* XConfigureEvent xconfigure; */
    /* XGravityEvent xgravity; */
    /* XResizeRequestEvent xresizerequest; */
    /* XConfigureRequestEvent xconfigurerequest; */
    /* XCirculateEvent xcirculate; */
    /* XCirculateRequestEvent xcirculaterequest; */
    /* XPropertyEvent xproperty; */
    /* XSelectionClearEvent xselectionclear; */
    /* XSelectionRequestEvent xselectionrequest; */
    /* XSelectionEvent xselection; */
    /* XColormapEvent xcolormap; */
    /* XClientMessageEvent xclient; */
    /* XMappingEvent xmapping; */
    /* XErrorEvent xerror; */
    /* XKeymapEvent xkeymap; */
    long[24] pad;
};

struct XComposeStatus {
    char* compose_ptr;
    int chars_matched;
}

extern (C) Display* XOpenDisplay(const char*);
extern (C) int XSelectInput(Display*, Window, EventMask);
extern (C) int XNextEvent(Display*, XEvent*);
extern (C) Bool XkbSetDetectableAutoRepeat(Display*, Bool, Bool*);
extern (C) KeySym XLookupKeysym(XKeyEvent*, int);
extern (C) int XLookupString(XKeyEvent*, char*, int, KeySym*, XComposeStatus*);

int find_before(MmFile f, uint pos, char c) {
    if(pos <= 0) return -1;
    while(pos > 0)
        if(f[--pos] == c)
            return cast(int)pos;
    return -1;
}

int find_after(MmFile f, uint pos, char c) {
    if(f[pos] == c) return cast(int)pos;
    while(pos < f.length()-1)
        if(f[++pos] == c)
            return cast(int)pos;
    return -1;
}

struct Split {
    uint top_left = 0;
    uint cursor = 100;
    MmFile fb;
}

struct Piece {

}

void redraw(Split s) {
    uint fidx = s.top_left;
    uint col = 0;
    uint line = 0;
    term.cursor_address(0, 0);
    /* term.clear_screen(); */
    while(line < term.height && fidx < s.fb.length()) {
        if(fidx == s.cursor) {
            term.set_background(7);
            term.set_foreground(0);
        } else if(fidx == 0 || fidx == s.cursor+1) {
            term.set_background(0);
            term.set_foreground(7);
        }
        char c = s.fb[fidx++];
        if(c == '\n') {
            term.clr_eol();
            line++;
            col = 0;
            term.cursor_address(line, col);
        } else {
            write(c);
            col++;
        }

        if(col >= term.width) {
            line++;
            col = 0;
            term.cursor_address(line, col);
        }
    }
    term.clr_eos();
    stdout.flush();
}

void main(string[] args) {
    Terminfo ti = parse_terminfo("/usr/share/terminfo/r/rxvt-unicode-256color");  // TODO path not hardcoded
    term = Terminal(ti);
    term.update_size();

    // setup stdin in mode. On exit, restore the old state
    termios[10] old_termios;  // there seem to be junk after the real termios info, loaded by tcgetattr. to avoid overwriting the world, we have a dummy array (but actually only use the 1st item) TODO =(
    tcgetattr(STDIN_FILENO, &old_termios[0]);
    term.old_termios = old_termios[0];

    scope(exit) cleanup_term();
    sigset(SIGWINCH, &size_update_handler);
    sigset(SIGINT,   &sigint_handler);
    sigset(SIGSEGV,  &sigsegv_handler);

    termios new_termios = old_termios[0];
    new_termios.c_lflag &= ~(ECHO | ICANON);
    tcsetattr(STDIN_FILENO, TCSANOW, &new_termios);

    string s_window_id = environment.get("WINDOWID");
    if(s_window_id is null) assert(0);
    int window_id = to!int(s_window_id);
    writeln("window id: ", window_id);

    Display* display = XOpenDisplay(null);
    Window current_window = window_id;
    XSelectInput(display, current_window, EventMask.KeyPressMask | EventMask.KeyReleaseMask);

    // dont emit 'release' events on keyrepeat, only 'pressed' ones
    Bool supported;
    XkbSetDetectableAutoRepeat(display, Bool.True, &supported);

    term.enter_ca_mode();
    term.clear_screen();
    term.cursor_invisible();
    stdout.flush();

    bool[] downed_key = new bool[KeySym.max];

    main_split.fb = new MmFile("main.d");
    main_split.top_left = 0;
    while(true) {
        main_split.redraw();

        XEvent ev;
        XNextEvent(display, &ev);
        switch(ev.type) {
            case EventType.KeyPress:
            {
                char str;
                KeySym key;
                int strlen = XLookupString(&ev.xkey, &str, 1, &key, null);
                bool is_repeat = downed_key[key];
                downed_key[key] = true;

                // C-y
                if(key == KeySym.y && downed_key[KeySym.Control_L]) {
                    if(main_split.top_left == 0) break;
                    int idx = find_before(main_split.fb, main_split.top_left-1, '\n');
                    if(idx == -1)
                        main_split.top_left = 0;
                    else
                        main_split.top_left = idx + 1;
                    /* term.cursor_address(0, 0); */
                    /* term.scroll_reverse(); */

                // C-e
                } else if(key == KeySym.e && downed_key[KeySym.Control_L]) {
                    int idx = find_after(main_split.fb, main_split.top_left, '\n');
                    if(idx != -1)
                        main_split.top_left = idx+1;
                    /* term.cursor_address(term.height-1, 0); */
                    /* term.scroll_forward(); */

                // C-d
                } else if(key == KeySym.d && downed_key[KeySym.Control_L]) {
                    for(uint i=0 ; i<term.height/2 ; i++) {
                        int idx = find_after(main_split.fb, main_split.top_left, '\n');
                        if(idx != -1)
                            main_split.top_left = idx+1;
                        else
                            break;
                    }

                // C-u
                } else if(key == KeySym.u && downed_key[KeySym.Control_L]) {
                    for(uint i=0 ; i<term.height/2 ; i++) {
                        if(main_split.top_left == 0) break;
                        int idx = find_before(main_split.fb, main_split.top_left-1, '\n');
                        if(idx == -1) {
                            main_split.top_left = 0;
                            break;
                        } else {
                            main_split.top_left = idx + 1;
                        }
                    }

                // 'arrows'
                } else if(key == KeySym.j) {
                    if(main_split.cursor != 0 && main_split.fb[main_split.cursor-1] != '\n')
                        main_split.cursor--;

                } else if(key == KeySym.m) {
                    if(main_split.cursor != main_split.fb.length()-1 && main_split.fb[main_split.cursor] != '\n')
                        main_split.cursor++;

                } else if(key == KeySym.k) {
                    int idx = find_after(main_split.fb, main_split.cursor, '\n');
                    if(idx != -1) {
                        int line_start = find_before(main_split.fb, main_split.cursor, '\n');
                        if(line_start == -1)  // for clarity
                            line_start = -1;
                        int line_offset = main_split.cursor - line_start;

                        int line_end = find_after(main_split.fb, idx + 1, '\n');
                        if(line_end == -1)
                            main_split.cursor = min(idx+line_offset, main_split.fb.length()-1);
                        else
                            main_split.cursor = min(idx + line_offset, line_end);
                    }

                } else if(key == KeySym.l) {
                    int idx = find_before(main_split.fb, main_split.cursor, '\n');
                    if(idx != -1) {
                        int line_offset = main_split.cursor-idx;
                        int previous_line_start = find_before(main_split.fb, idx, '\n');
                        if(previous_line_start == -1)
                            previous_line_start = -1;

                        main_split.cursor = previous_line_start + min(line_offset, idx-previous_line_start);
                    }

                } else if(key == KeySym.dollar) {
                    int idx = find_after(main_split.fb, main_split.cursor, '\n');
                    if(idx == -1)
                        idx = cast(int)main_split.fb.length()-1;
                    main_split.cursor = idx;

                } else if(key == KeySym._0) {
                    int idx = find_before(main_split.fb, main_split.cursor, '\n');
                    main_split.cursor = idx == -1 ? 0 : idx + 1;

                }

                break;
            }

            case EventType.KeyRelease:
            {
                char str;
                KeySym key;
                int strlen = XLookupString(&ev.xkey, &str, 1, &key, null);
                downed_key[key] = false;
                break;
            }

            default: assert(0);
        }
    }
}
