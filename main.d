import autogen.caps;
import std.stdio;
import std.conv;
import std.array;
import std.string;
import core.vararg;
import core.thread;
import std.algorithm;
import std.random;
import core.sys.posix.signal;
import core.stdc.stdlib;
import core.sys.posix.sys.ioctl;

enum SIGWINCH = 28;

/*
   Info about the terminfo compiled format are hard to find,
   as almost everyone uses ncurses / tic / infocmp / tput

   Most relevant stuff was found on:

    - terminfo(5)   [! the capacity list is sorted by alphabetical order,
                       not in order of appearance in a terminfo file ]
                    [ it probably is generated by ncurses/man/MKterminfo.sh, which sorts it ]
    - Terminfo Source Format (ENHANCED CURSE) on the Single UNIX Specification - opengroup.org
    - unibilium's header description (unibilium/secret/terminfo.pod)


    - tic's source (ncurses/include/tic.h) [ only available resource with the
                                             ordered capacity table? ]

    A lot of ncurses' terminfo handling code seem to be generated using ncurses/include/Caps file
    There are a bunch of awk / makefile / sh scripts using it in ncurses/ncurses/tinfo/ and in ncurses/man

    TODO a bit more doc
*/

// TODO terminfo extended capacities

struct Terminfo {
    struct Header {
        ushort magic;
        ushort name_size;
        ushort bool_count;
        ushort num_count;
        ushort string_count;
        ushort table_size;
    };

    Header header;
    string name;
    string description;
    bool[] bools;
    ushort[] nums;
    char[][] strings;
}

struct Terminal {
    Terminfo info;
    int width;
    int height;

    void update_size() {
        winsize size;
        ioctl(0, TIOCGWINSZ, &size);
        width  = size.ws_col;
        height = size.ws_row;
    }
}

Terminfo parse_terminfo(string path) {
    File f = File(path, "r");
    Terminfo ti;
    f.rawRead((&ti.header)[0..1]);
    assert(ti.header.magic == octal!432);

    // name <=> term_name | [ ... | ] description
    char[] _name_section = new char[ti.header.name_size];
    f.rawRead(_name_section);
    string name_section = cast(string)_name_section;
    string[] splitted_name = name_section.split("|");
    assert(splitted_name.length >= 2);
    ti.name = splitted_name[0];
    ti.description = splitted_name[$-1][0..$-1];  // remove trailing \0

    ti.bools = new bool[ti.header.bool_count];
    f.rawRead(ti.bools);

    if((ti.header.name_size + ti.header.bool_count) % 2 != 0)
        f.seek(1, SEEK_CUR);  // padding

    ti.nums = new ushort[ti.header.num_count];
    f.rawRead(ti.nums);

    // string table

    ushort[] string_offsets = new ushort[ti.header.string_count];
    f.rawRead(string_offsets);
    char[] string_table = new char[ti.header.table_size];
    f.rawRead(string_table);
    ti.strings = new char[][ti.header.string_count];
    foreach(i, off; string_offsets)
        if(off != 0xffff) {
            assert(off < 0x7fff);
            long string_end = indexOf(string_table, '\0', off);
            if(off == string_end) {
                ti.strings[i] = new char[0];
            } else {
                assert(string_end > off,
                       format("index error %d, at %d, offset %u",
                              string_end, i, off));
                ti.strings[i] = string_table[off..string_end];
            }
        }

    return ti;
}

void print_term_caps(const ref Terminfo ti) {
    writeln("bools:");
    foreach(i, b; ti.bools)
        if(b)
            writefln("\t%s", cast(bool_caps)i);

    writeln();
    writeln("nums:");
    foreach(i, n; ti.nums)
        if(n != 0xffff)
            writefln("\t%s = %d", cast(num_caps)i, n);

    /* writeln(); */
    /* writeln("strings:"); */
    /* foreach(i, s; ti.strings) */
    /*     if(s.length != 0) */
    /*         writefln("\t%s = %s", cast(str_caps)i, ti.strings[i]); */
}


// TODO very slow to do this every time (setb/g strings are pretty huge for instance)
// TODO string cap interpretation only supports int args atm
// (xterm & rxvt only seem to need ints)
// but the spec allows string as arguments
// TODO 'u6' cap does a %d with nothing on the stack...

string _interpret_cap(string s, ref uint i, ref int[] stack, ref int[] args, bool eval) {
    // i <=> string index
    string o = "";
    while(i < s.length) {
        char c = s[i++];
        if(c != '%') {
            if(eval)
                o ~= c;
        } else {
            c = s[i++];
            switch(c) {
                case '%':
                    if(!eval) break;
                    o ~= '%';
                    break;

                case 'd':
                    if(!eval) break;
                    assert(stack.length > 0);
                    o ~= to!string(stack.back);
                    stack.popBack();
                    break;

                case 'p':
                    if(!eval) break;
                    char n = s[i++];
                    assert(n >= '1' && n <= '9');
                    int arg_idx = (n - '1');
                    assert(arg_idx < args.length);
                    stack ~= args[arg_idx];
                    break;

                case 'i':
                    if(!eval) break;
                    if(args.length > 0) args[0]++;
                    if(args.length > 1) args[1]++;
                    break;

                case '{':
                    int n = 0;
                    while(true) {
                        char d = s[i++];
                        if(d == '}')
                            break;
                        else if(d >= '0' && d <= '9')
                            n = 10*n + (d - '0');
                        else
                            assert(0);
                    }
                    if(!eval) break;
                    stack ~= n;
                    break;

                case '?':
                    o ~= _interpret_cap(s, i, stack, args, eval);  // read & interpret everything inside the condition
                    assert(s[i] == 't');
                    i++;
                    bool current_eval = eval;
                    while(true) {
                        bool eval_then = false;
                        bool eval_else = false;
                        if(current_eval) {
                            assert(stack.length > 0);
                            if(stack.back != 0)
                                eval_then = true;
                            else
                                eval_else = true;
                            stack.popBack();
                        }
                        o ~= _interpret_cap(s, i, stack, args, eval_then);
                        char next = s[i++];
                        if(next == ';')
                            break;
                        assert(next == 'e');
                        o ~= _interpret_cap(s, i, stack, args, eval_else);
                        next = s[i++];
                        if(next == ';')
                            break;
                        assert(next == 't', "expected ; or t after e, got " ~ to!string(next));  // "else-if a la Algol 68"
                        current_eval = eval_else;
                    }
                    break;

                // TODO autogen logical operations
                case '>':
                    if(!eval) break;
                    assert(stack.length >= 2);
                    int a = stack.back;
                    stack.popBack();
                    int b = stack.back;
                    stack.popBack();
                    stack ~= (b > a) ? 1 : 0;  // TODO seemed more logical to swap the args but its against the spec, which may no be correct
                    break;

                case '=':
                    if(!eval) break;
                    assert(stack.length >= 2, "trying to eval = but cannot pop twice. stack is: " ~ to!string(stack) ~ ", before: " ~ s[0..i] ~ " ; after: " ~ s[i+1..$]);
                    int a = stack.back;
                    stack.popBack();
                    int b = stack.back;
                    stack.popBack();
                    stack ~= (b == a) ? 1 : 0;  // TODO seemed more logical to swap the args but its against the spec, which may no be correct
                    break;

                case ';':
                case 'e':
                case 't':
                    i--;
                    return o;

                // TODO handle everything else
                default: assert(0, "unknown cap param type %" ~ to!string(c));
            }
        }
    }
    return o;
}

string interpret_string_cap(ref Terminfo ti, str_caps cap, int[] args...) {
    // TODO asserts should also crash in release mode
    assert(cap < ti.header.string_count && ti.strings[cap].length > 0);
    string s = ti.strings[cap].idup;
    assert(s.indexOf('<') == -1);  // TODO
    assert(s.indexOf('^') == -1);  // TODO
    assert(s.indexOf("%s") == -1);  // TODO

    int[] stack;
    uint str_idx = 0;
    string o = _interpret_cap(s, str_idx, stack, args, true);
    assert(str_idx == s.length);
    return o;
}

Terminal term;  // for the signal handlers

extern(C)
void size_update_handler(int d=0) {
    term.update_size();

    static if(1) {  // fill screen (except a border) with a random color
        static color = 0;
        color = (color+1)%10;
        write(interpret_string_cap(term.info, str_caps.clear_screen, color));
        write(interpret_string_cap(term.info, str_caps.set_background, color));
        write(interpret_string_cap(term.info, str_caps.set_foreground, color));
        for(uint i=1 ; i<term.width-1 ; i++)
            for(uint j=1 ; j<term.height-1 ; j++) {
                write(interpret_string_cap(term.info, str_caps.cursor_address, j, i));
                write(" ");
            }
        stdout.flush();
    }
}

void cleanup_cursor() {
    /* write(interpret_string_cap(term.info, str_caps.cursor_normal)); */
    /* write(interpret_string_cap(term.info, str_caps.restore_cursor)); */
    write(interpret_string_cap(term.info, str_caps.exit_ca_mode));
    writeln("cleaning up...");
}

extern(C) void sigint_handler(int d) {
    cleanup_cursor();
    writeln("caught sigint");
    assert(0);  // TODO =(
}

extern(C) void sigsegv_handler(int d) {
    cleanup_cursor();
    writeln("caught sigsegv");
    assert(0);  // TODO =(
}

void main(string[] args) {
    Terminfo ti = parse_terminfo("/usr/share/terminfo/r/rxvt-unicode-256color");
    term = Terminal(ti);
    term.update_size();
    /* print_term_caps(ti); */

    /* str_caps cap = str_caps.clear_screen; */
    /* str_caps cap = str_caps.parm_rindex; */
    /* writeln(interpret_string_cap(ti, cap, 2).replace("\033", "\\033")); */
    /* write(interpret_string_cap(ti, cap, 3)); */


    static if(0) {
        write(interpret_string_cap(ti, str_caps.clear_screen));
        write(interpret_string_cap(ti, str_caps.cursor_address, 7, 22));
        write(interpret_string_cap(ti, str_caps.enter_bold_mode));
        write(interpret_string_cap(ti, str_caps.enter_italics_mode));

        assert(args.length > 2);
        write(interpret_string_cap(ti, str_caps.set_background, to!int(args[1])));
        write(interpret_string_cap(ti, str_caps.set_foreground, to!int(args[2])));
        writeln("plouf");
    } else if(0) {
        for(uint i=0 ; i<20 ; i++) {
            write(interpret_string_cap(ti, str_caps.set_background, i));
            writeln("plouf");
        }
    }

    /* writeln(interpret_string_cap(ti, str_caps.set_background, to!int(args[1])).replace("\033", "\\033")); */

    sigset(SIGWINCH, &size_update_handler);
    sigset(SIGINT,   &sigint_handler);
    sigset(SIGSEGV,  &sigsegv_handler);

    write(interpret_string_cap(ti, str_caps.enter_ca_mode));

    /* while(true) {} */

    scope(exit) cleanup_cursor();

    /* *cast(char*)0 = 0;  // force segfault */

    static if(1) {
        // snake demo

        write(interpret_string_cap(ti, str_caps.save_cursor));
        write(interpret_string_cap(ti, str_caps.clear_screen));
        write(interpret_string_cap(ti, str_caps.cursor_invisible));

        int[] snake_x = new int[10];
        int[] snake_y = new int[10];
        snake_x[] = 10;
        snake_y[] = 10;

        int next_move_in = 0;
        int[] dir = [0, 1];

        while(true) {
            if(next_move_in-- <= 0) {
                int new_dir = uniform(0, 2)*2-1;  // -1 or 1
                if(dir[0] == 0) {
                    dir[0] = new_dir;
                    dir[1] = 0;
                } else {  // dir.y == 0
                    dir[0] = 0;
                    dir[1] = new_dir;
                }
                next_move_in = uniform(5, 50);
            }

            snake_x ~= (snake_x.back + dir[0] + term.width)  % term.width;
            snake_y ~= (snake_y.back + dir[1] + term.height) % term.height;

            write(interpret_string_cap(ti, str_caps.set_background, 6));
            write(interpret_string_cap(ti, str_caps.set_foreground, 6));
            for(uint i=1 ; i<snake_x.length ; i++) {
                write(interpret_string_cap(ti, str_caps.cursor_address, snake_y[i], snake_x[i]));
                write(" ");
            }

            write(interpret_string_cap(ti, str_caps.restore_cursor));
            write(interpret_string_cap(ti, str_caps.cursor_address, snake_y[0], snake_x[0]));
            /* write(cast(char)uniform('a', 'z'+1)); */
            write("Joran "[uniform(0, 6)]);

            snake_x = snake_x.remove(0);
            snake_y = snake_y.remove(0);

            stdout.flush();
            Thread.sleep(dur!("msecs")(5));
        }
    }

}
